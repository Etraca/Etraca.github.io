---
layout:     post
title:      HashMap学习笔记
subtitle:   HashMap学习笔记
date:       2018-12-26
author:     WPF
header-img: img/post-bg-cook.jpg
catalog: true
tags:
- 散列表
- java
---

## 概述
HashMap 最早出现在 JDK 1.2中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在进行某些操作后，键值对的顺序可能会发生变化。另外，需要注意的是，HashMap 是非线程安全类，在多线程环境下可能会存在问题。
## 散列表
- 散列表用的是数组支持的按下表随机访问数据的特性，所以散列表其实是数组的一种拓展。
- 散列函数：我们可以定义为hash(key),其中key表示元素的键值
    - 计算出来的散列值是一个非负整数（底层数组的下标）
    - 如果key1=key2,那么hash(key1)==hash(key2)
    - 如果key1≠key2,那么hash(key1)≠hash(key2)
- 散列冲突：在真实的情况下，要找到不同的key对应的散列值不一致的散列函数几乎不可能，散列冲突无法避免，而且数组的大小也有限，也会增大散列冲突的概率
    - 开放寻址法：发现冲突后继续往后查找直到有空闲的位置
    - 拉链法（链表法）：数组的每一个位置对应一个桶（bucket），每一个bucket后面跟一个链表 ，为增加查询效率也可以是跳表，红黑树
![](https://segmentfault.com/img/remote/1460000012926727?w=1598&h=752)

## 容量计算
```java
static final int tableSizeFor(int cap) {
        // 核心操作在于给数据的最高位新增1
        // 减一的原因是：如果cap本身就是2个幂，不减一则计算完后面的无符号位移就变成cap的两倍了。
        int n = cap - 1;
        n |= n >>> 1; // 0000011xxxxxx 至少两个1
        n |= n >>> 2; // 0001111xxxxxx 至少4个1
        n |= n >>> 4; // 00011111111xxxxx 至少8个1
        n |= n >>> 8; // 00001111111111111111xxxx 至少16个1
        n |= n >>> 16; // 11111111111111111111111111111111 32个1 = MAXIMUM_CAPACITY
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```
![](https://segmentfault.com/img/remote/1460000012926728?w=1600&h=994)
    
## 查找
HashMap的查找先定位键值对所在的桶的位置，然后再对链表（O(n)）或红黑树(O(logn))进行查找。通过这两步即可完成查找，该操作相关代码如下：

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    // 1. 定位键值对所在桶的位置
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            // 2. 如果 first 是 TreeNode 类型，则调用黑红树查找方法
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                
            // 2. 对链表进行查找
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```
这段代码中的这句代码比较难理解：

```java
// index = (n - 1) & hash
first = tab[(n - 1) & hash]
```
这里是通过n - 1) & hash 计算桶的位置，由于HashMap中length的大小永远是2的幂，所有(n - 1) & hash 等价于对 length 取余，这样做的好处是位运算的效率比取余操作效率高

## hash方法
先看源代码：

```java 
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
可以看到HashMap的hash函数没有直接使用键值对象的原始hash，而是做了位运算。原因在于上一节中求余运算，一般的情况n相对比较小，所以hash只有低位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以将 hash 高16位数据与低16位数据进行异或运算，即 hash ^ (hash >>> 16)。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。
重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。



