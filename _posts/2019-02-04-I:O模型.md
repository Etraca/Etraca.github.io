---
layout:     post
title:      I/O模型
subtitle:   I/O模型
date:       2019-01-04
author:     WPF
header-img: img/post-bg-cook.jpg
catalog: true
tags:
- I/O模型
---
## 阻塞 I/O 模型
阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。相关示意图如下：

![](https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15180090652103.jpg)
上图中，应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就阻塞住了。直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。

## 非阻塞 I/O 模型
与阻塞 I/O 模型相反，在非阻塞 I/O 模型下。应用进程与内核交互，目的未达到时，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备好没。示意图如下：

![](https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15180140157823.jpg)
上图中，应用进程通过 recvfrom 系统调用不停的去和内核交互，直到内核准备好数据报。从上面的流程中可以看出，应用进程进入轮询状态时等同于阻塞，所以非阻塞的 I/O 似乎并没有提高进程工作效率。

##  I/O 复用模型
select 有三个文件描述符集（readfds），分别是可读文件描述符集（writefds）、可写文件描述符集和异常文件描述符集（exceptfds）。应用程序可将某个 socket （文件描述符）设置到感兴趣的文件描述符集中，并调用 select 等待所感兴趣的事件发生。比如某个 socket 处于可读状态了，此时应用进程就可调用 recvfrom 函数把数据从内核空间拷贝到进程空间内，无需再等待内核准备数据了。示意图如下：

![](https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15180556060991.jpg)
一般情况下，应用进程会将多个 socket 设置到感兴趣的文件描述符集中，并调用 select 等待所关注的事件（比如可读、可写）处于就绪状态。当某些 socket 处于就绪状态后，select 返回处于就绪状态的 sockct 数量。注意这里返回的是 socket 的数量，并不是具体的 socket。应用程序需要自己去确定哪些 socket 处于就绪状态了，确定之后即可进行后续操作。

I/O 复用本身不是很好理解，所以这里还是举例说明吧。话说公司的运维部连续辞退两个运维同学后，运维部的 leader 觉得需要亲自监督一下大家工作。于是 leader 在周会上和大家说，从下周开始，所有的发布邮件都由他接收，并由他转发给相关运维同学，同时也由他重启服务。各位运维同学需要告诉 leader 各自所负责监控的项目，服务重启好后，leader 会通过内部沟通工具通知相关运维同学。至于服务重启的结果（成功或失败），leader 不关心，需要运维同学自己去看。运维同学看好后，需要把结果回复给开发同学。

![](https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15180681282120.jpg)
1. 开发同学将发布邮件发送给运维 leader，并指明这个邮件应该转发给谁
2. 运维告诉 leader，如果有发给我的邮件，请发送给我
3. leader 把邮件转发给相关的运维同学，并着手重启服务
4. 运维同学看完邮件，告诉 leader 某某服务重启好后，请告诉我
5. 服务重启好，leader 通知运维同学xx服务启动好了
6. 运维同学查看服务启动情况，并返回信息给开发同学

这种方式为什么可以提高工作效率呢？原因在于运维同学一股脑把他所负责的几十个项目都告诉了 leader，由 leader 重启服务，并通知运维同学。运维同学这个时候等待 leader 的通知，只要其中一个或几个服务重启好了，运维同学就回接到通知，然后就可去干活了。而不是像以前一样，非要等某个服务重启好再进行后面的工作。

说一下上面例子的角色扮演。开发同学是客户端，leader 是内核。开发同学发的邮件相当于网络请求，leader 接收邮件，并重启服务，相当于内核准备数据。运维同学是服务端应用进程，告诉 leader 自己感兴趣的事情，并在最后将事情的处理结果返回给开发同学。

## 信号驱动式 I/O 模型
信号驱动式 I/O 模型是指，应用进程告诉内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。示意图如下：

![](https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15180719994697.jpg)
## 异步 I/O 模型
异步 I/O 是指应用进程把文件描述符传给内核后，啥都不管了，完全由内核去操作这个文件描述符。内核完成相关操作后，会发信号告诉应用进程，某某 I/O 操作我完成了，你现在可以进行后续操作了。示意图如下：

![](https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15180089800822.jpg)
上图通过 aio_read 把文件描述符、数据缓存空间，以及信号告诉内核，当文件描述符处于可读状态时，内核会亲自将数据从内核空间拷贝到应用进程指定的缓存空间呢。拷贝完在告诉进程 I/O 操作结束，你可以直接使用数据了。
## 总结
上面介绍了5种 I/O 模型，也通过举例的形式对每种模型进行了补充说明，不知道大家看懂没。抛开上面的 I/O 模型不谈，如果某种 I/O 模型能让进程的工作的时间大于等待的时间，那么这种模型就是高效的模型。在服务端请求量变大时，通过 I/O 复用模型可以让进程进入繁忙的工作状态中，减少忙等，进而提高了效率。

I/O 复用模型结果数次改进，目前性能已经很好了，也得到了广泛应用。像 Nginx，lighttd 等服务器软件都选用该模型。好了，关于 I/O 模型就说到这里。

最后附一张几种 I/O 模型的对比图：

![](https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15180794109268.jpg)



