---
layout:     post
title:      Java对象的创建过程
subtitle:   Java对象的创建过程
date:       2019-01-13
author:     WPF
header-img: img/post-bg-cook.jpg
catalog: true
tags:
- jvm
- java
---

## 概述
Java是门面向对象的编程语言，在Java程序运行的过程中无时无刻都有对象被创建，在语言层面或许只要一个new关键字就可以了，而在虚拟机中，对象的创建又是一个什么样的过程呢？本文就来捋一捋Java对象创建的整个过程

## 类加载检查
JVM遇到一个new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用的类是否已经被加载、解析和初始化过。如果没有，那必须先执行响应的类加载过程

##内存分配
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需要的内存大小在类加载之后就能确定，为对象分配内存的任务等同于把一块确定大小的内存从Java堆中划分下来。JVM划分内存主要有两种方式：指针碰撞和空闲列表

- 指针碰撞:假设JVM堆中的内存是绝对规整的，所有用过的内存在一边，未用过的放在另外一边，中间放着一个指针作为分界点的指示器，那分配内存就相当于指针香空闲空间的那一边移动一段和对象大小相等的距离，这种分配方式就是”指针碰撞“.
- 空闲列表：如果JVM堆中的内存不是规整的，已使用的内存和未使用的内存互相交错，那就没办法使用”指针碰撞“了，虚拟机会维护一个列表，记录那些内存是可用的，分配的时候重列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式就是”空闲列表“.

又上可知，JVM选用哪种分配方式由JVM堆是否规整决定，而JVM堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
因此，在使用Serial、ParNew等带有compact过程的收集器时，系统采用的分配方式是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。

系统除了要考虑内存的分配方式外，还要考虑使用哪种方式内存分配过程的线程安全。因为内存分配是一个非常频繁的行为，而且jvm堆又是所有内存共享，所有并发问题不可避免。虚拟机通常采用两种方式来解决这个问题：

1. 同步：虚拟机采用CAS加上失败重试的方式保证分配操作的原子性
2. TLAB: 虚拟机把内存分配的动作按照线程划分到不同的空间之中进行，即每个线程预先在Java堆中分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程需要分配内存就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB可以同过-XX:+/-UseTLAB参数来设定。

## 空间清零
内存分配完之后，虚拟机会对分配到的内存空间都初始化为零值，当然对象头除外。如果使用TLAB，这一工作将提前到TLAB分配时进行，这个操作保证了对象的实例字段在Java代码中可以不赋初值就可以使用，程序能访问到这些字段的数据类型所对应的零值。

## 对象头设置
虚拟机会对对象进行必要的设置，例如对象的类信息、元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息到存放在对象头中，根据对象的运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。

## 对象初始化
在执行完new指令后，虚拟机会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个对象才算完整的产生。



