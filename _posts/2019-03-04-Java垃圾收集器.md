---
layout:     post
title:      Java垃圾收集器
subtitle:   Java垃圾收集器
date:       2019-03-04
author:     WPF
header-img: img/post-bg-cook.jpg
catalog: true
tags:
- jvm
- gc
- java
---

## 简述
JVM运行时数据区域中，程序计数器、虚拟机栈和本地方法栈三个区域的数据随着线程而生，随着线程而死，所以不需要考虑其垃圾回收的问题。而Java的堆和方法区则不一样，所以垃圾回收主要关注的就是这一部分的内存。

## 对象存活判定算法
#### 引用计数算法
给对象中添加一个引用计数器，每当有一个地方引用了这个对象，那么计数器+1；当引用失效后，计数器-1；任何时刻计数器的值为0的时候，对象就是不可能再被使用的了。这就是引用计数算法。
引用计数算法是一种实现简单、判定效率也非常高的算法，但是它无法解决对象之间循环引用的问题，比如A对象引用了B对象，B对象引用了A对象，虽然A=null,B=null,但是引用依然存在。在Java中这种情况还是会回收的，所以Java并不是使用引用计数算法来标记对象是否存活的。

#### 可达性分析算法
Java主要是通过可达性分析算法来判断对象是否存活的，这个算法的基本思想就是通过一系列”GC Roots“的对象作为起点，从这些起点想下搜索，，搜索走过的路径成为”引用链“，**当一个对象到”GC Roots“没有任何引用链时即”GC Roots“到这个对象不可达，则这个对象是不可用的**。所以在Java中虽然某些对象之间虽然相互关联，但是它们到”GC Roots“是不可达的，所以它们也是”已死“对象。

Java中可以被成为”GC Roots“的对象包括：
* 虚拟机栈和本地方法栈中局部变量表中引用的对象
* 方法区中静态变量引用的对象
* 方法区中常量引用的对象

注意：GC Roots存在的区域数据非常之多，如果要逐个检查它们的引用效率非常低，所以在jvm中使用一个OopMap的数据结构在类加载时期就记录这些引用。这样GC在扫描的时候就能直接得到这些引用信息了。

#### 方法区的回收
方法区的垃圾回收效率非常低，它主要回收两个部分：废弃常量和无用的类。废弃常量和堆中的对象基本类似，如字符串常量”ABC“，如果已经没有任何String对象引用它了，那么在下次回收方法区是”ABC“有可能被回收。
判断一个常量是”废弃常量“比较简单，但是要判断一个类是”无用的类“的条件则非常苛刻。类需要同时满足下面的条件才能成为”无用的类“：
* 该类的所有实例对象都已经被回收。Java堆中已经不存在任何该类的实例。
* 加载该类的classloader也已经被回收。
* 该类对应的Class对象没有在任何对象中引用，无法在任何地方可以通过反射的方式来访问该类的方法。

虚拟机可以对同时满足以上三个条件的”无用类“进行回收。但是这个操作也不是强制的。

## 垃圾回收算法
#### 标记-清除算法
标记-清除（Mark-Sweep）算法主要分为两个阶段：首先通过可达性分析算法标记需要回收的对象，然后再标记完成之后统一回收所有被标记的对象。
该算法是最基础的收集算法，它主要有下面两个不足之处：
1. 效率问题，标记和清除两个过程的效率都非常低。
2. 空间问题，标记清除之后会产生大量的不连续内存碎片，空间碎片太多会导致无法分配较大的对象，甚至可能会提前触发另一次垃圾收集操作。

#### 复制算法
复制算法是为了解决标记清除算法效率问题而出现的。它将可用的内存空间分为大小相等的AB两块，每次都只使用其中一块，当A空间用完的时候，这所有还存活的对象都复制到另一块B空间，然后将原先使用的A空间全部清理，然后开始使用B空间，循环。
复制算法每次都对整个半区就行清理，也就不用考虑空间碎片的问题，只要一动对顶的指针分配内存即可，实现简单，运行高效。但是这种算法会将内存分为两半，最多只能使用可用内存的一半，造成空间浪费。

Java虚拟机一半都采用这种方式来回收新生代，因为新生代的对象一半都是”朝生夕死“，并不需要按照1：1的比例来分配空间，而是将内存分为很大的一块Eden空间和两块较小的survivor空间，每次使用Eden和其中一块survivor空间（from）。当回收时，将Eden和from空间的存活对象都移动到另一块survivor空间（to）中。最后清理掉Eden和from空间。JVM默认Eden和survivor的大小比是8：1：1，所以新生代中的可用容量为整个新生代容量的90%，只有10%被”浪费”掉。
当然也有可能回收，to survivor空间不够用，这时候就需要老年代进行分配担保。

#### 标记-整理算法
复制算法在对象存活率比较高时就需要进行较多的复制操作，效率将会变低。而且如果不想浪费50的空间，就需要额外的空间就行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般都不采用这种算法。
根据老年代的特点，有人提出了“标记-整理”(mark-Compact)算法，标记的过程依然和标记-清除算法一样，但后续的步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动，然年清理掉另一端的内存。

#### 分代收集算法
根据对象的存活周期的不同，将内存分成几块。一般是把Java堆分成新生代和老年代。这样就可以根据各个年代的特点采用最合适的收集算法。
在新生代中每次垃圾回收时都有大量的对象死去，只有少量存活，那就使用复制算法，只需要付出少量对象的复制成本就可以完成收集。而老年代因为对象的存活率高，没有额外的空间对它分配担保，就必须使用标记-清除或者标记-整理算法来进行回收。


