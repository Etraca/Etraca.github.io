---
layout:     post
title:      Java垃圾收集器
subtitle:   Java垃圾收集器
date:       2019-03-04
author:     WPF
header-img: img/post-bg-cook.jpg
catalog: true
tags:
- jvm
- gc
- java
---

## 简述
JVM运行时数据区域中，程序计数器、虚拟机栈和本地方法栈三个区域的数据随着线程而生，随着线程而死，所以不需要考虑其垃圾回收的问题。而Java的堆和方法区则不一样，所以垃圾回收主要关注的就是这一部分的内存。

## 对象存活判定算法
#### 引用计数算法
给对象中添加一个引用计数器，每当有一个地方引用了这个对象，那么计数器+1；当引用失效后，计数器-1；任何时刻计数器的值为0的时候，对象就是不可能再被使用的了。这就是引用计数算法。
引用计数算法是一种实现简单、判定效率也非常高的算法，但是它无法解决对象之间循环引用的问题，比如A对象引用了B对象，B对象引用了A对象，虽然A=null,B=null,但是引用依然存在。在Java中这种情况还是会回收的，所以Java并不是使用引用计数算法来标记对象是否存活的。

#### 可达性分析算法
Java主要是通过可达性分析算法来判断对象是否存活的，这个算法的基本思想就是通过一系列”GC Roots“的对象作为起点，从这些起点想下搜索，，搜索走过的路径成为”引用链“，**当一个对象到”GC Roots“没有任何引用链时即”GC Roots“到这个对象不可达，则这个对象是不可用的**。所以在Java中虽然某些对象之间虽然相互关联，但是它们到”GC Roots“是不可达的，所以它们也是”已死“对象。

Java中可以被成为”GC Roots“的对象包括：
* 虚拟机栈和本地方法栈中局部变量表中引用的对象
* 方法区中静态变量引用的对象
* 方法区中常量引用的对象

注意：GC Roots存在的区域数据非常之多，如果要逐个检查它们的引用效率非常低，所以在jvm中使用一个OopMap的数据结构在类加载时期就记录这些引用。这样GC在扫描的时候就能直接得到这些引用信息了。

#### 方法区的回收
方法区的垃圾回收效率非常低，它主要回收两个部分：废弃常量和无用的类。废弃常量和堆中的对象基本类似，如字符串常量”ABC“，如果已经没有任何String对象引用它了，那么在下次回收方法区是”ABC“有可能被回收。
判断一个常量是”废弃常量“比较简单，但是要判断一个类是”无用的类“的条件则非常苛刻。类需要同时满足下面的条件才能成为”无用的类“：
* 该类的所有实例对象都已经被回收。Java堆中已经不存在任何该类的实例。
* 加载该类的classloader也已经被回收。
* 该类对应的Class对象没有在任何对象中引用，无法在任何地方可以通过反射的方式来访问该类的方法。

虚拟机可以对同时满足以上三个条件的”无用类“进行回收。但是这个操作也不是强制的。

## 垃圾回收算法
#### 标记-清除算法
标记-清除（Mark-Sweep）算法主要分为两个阶段：首先通过可达性分析算法标记需要回收的对象，然后再标记完成之后统一回收所有被标记的对象。
该算法是最基础的收集算法，它主要有下面两个不足之处：
1. 效率问题，标记和清除两个过程的效率都非常低。
2. 空间问题，标记清除之后会产生大量的不连续内存碎片，空间碎片太多会导致无法分配较大的对象，甚至可能会提前触发另一次垃圾收集操作。

#### 复制算法
复制算法是为了解决标记清除算法效率问题而出现的。它将可用的内存空间分为大小相等的AB两块，每次都只使用其中一块，当A空间用完的时候，将所有还存活的对象都复制到另一块B空间，然后将原先使用的A空间全部清理，然后开始使用B空间，循环。
复制算法每次都对整个半区就行清理，也就不用考虑空间碎片的问题，只要一动对顶的指针分配内存即可，实现简单，运行高效。但是这种算法会将内存分为两半，最多只能使用可用内存的一半，造成空间浪费。

Java虚拟机一般都采用这种方式来回收新生代，因为新生代的对象一半都是”朝生夕死“，并不需要按照1：1的比例来分配空间，而是将内存分为很大的一块Eden空间和两块较小的survivor空间，每次使用Eden和其中一块survivor空间（from）。当回收时，将Eden和from空间的存活对象都移动到另一块survivor空间（to）中。最后清理掉Eden和from空间。JVM默认Eden和survivor的大小比是8：1：1，所以新生代中的可用容量为整个新生代容量的90%，只有10%被”浪费”掉。
当然也有可能回收时，to survivor空间不够用，这时候就需要老年代进行分配担保。

#### 标记-整理算法
复制算法在对象存活率比较高时就需要进行较多的复制操作，效率将会变低。而且如果不想浪费50%的空间，就需要额外的空间就行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般都不采用这种算法。
根据老年代的特点，有人提出了“标记-整理”(mark-Compact)算法，标记的过程依然和标记-清除算法一样，但后续的步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动，然年清理掉另一端的内存。

#### 分代收集算法
根据对象的存活周期的不同，将内存分成几块。一般是把Java堆分成新生代和老年代。这样就可以根据各个年代的特点采用最合适的收集算法。
在新生代中每次垃圾回收时都有大量的对象死去，只有少量存活，那就使用复制算法，只需要付出少量对象的复制成本就可以完成收集。而老年代因为对象的存活率高，没有额外的空间对它分配担保，就必须使用标记-清除或者标记-整理算法来进行回收。

## 垃圾收集器
#### Serial 收集器
Serial是最基本的也是发展历史最悠久的收集器，是一个单线程收集器。**它在进行垃圾回收时需要“Stop The World”，必须暂停其他所有工作线程，知道它收集完成。**
它收集过程是这样的，到达safepoint之后先暂停所有用户线程，然后新生代采取复制算法收集垃圾，老年代采用标记-整理算法收集垃圾。
Serial收集器虽然是单线程，而且要暂停所有用户线程，但是它依然是Client模式下虚拟机的默认新生代收集器。它的优点是，简单而高效，对于限定的单个CPU环境而言，由于没有线程交互的开销，专心做垃圾收集自然能获得最高的单线程效率。

#### ParNew收集器
ParNew收集器就是Serial收集器的多线程版本。ParNew收集器的收集算法、Stop The World、对象分配规则、回收策略等和Serial收集器基本没有区别。
ParNew是server模式下虚拟机新生代默认的收集器，其中一个与性能无关的因素是，除了Serial之外，它是唯一能和CMS老年代收集器搭配的收集器。如果你使用了-XX:+UseConcMarkSweepGC来指定老年代收集器之后，新生代的默认收集器就是ParNew了。当然你也可以使用-XX:+UseParNewGC来指定。
tips:**它默认开启的收集线程数和CPU的个数相同，但服务器机器CPU太多的情况可以使用-XX:ParallelGCThread参数来限制垃圾收集的线程数**

#### Parallel Scavenge 收集器
Parallel Scavenge也是一个使用复制算法的，并行多线程的，新生代收集器。它与ParNew不通的是，它的关注点不是GC的停顿时间，而是GC的吞吐量。
何为吞吐量，吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后头运算而不需要太多交互的系统。
Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集时间的-XX:MaxGCPauseMills和直接设置吞吐量大小的-XX:GCTimeRatio。当然也可以使用-XX:UseAdativeSizePolicy参数来根据系统的运行情况自动调节新生代的大小（-Xmn）、Eden和Surivor的比例（-XX:SurivorRatio）、晋升老年代对象的大小（-XX:PretennureSizeThreshold）等参数，以提供合适的停顿时间和最大吞吐量。**自适应调节是Parallel Scavenge收集器和ParNew收集器的一个重要的区别。**

#### Serial Old收集器
Serial Old收集器是Serial收集器的老年代版本。但是它使用的是标记-整理算法，它主要也是提供给Client模式下的虚拟机使用。
如果它用在Server模式下，还有如下作用：
* 能与JDK 1.5之前Parallel Scavenge收集器搭配使用
* CMS收集器发生Concurrent Mode Failure时当做备用方案

它的收集过程是：Stop The World 然后使用标记-整理算法收集垃圾。

#### Parallel Old收集器
Parallel Old收集器是Parallel Scavenge收集器的老年代版本。使用多线程加标记-整理算法，也是“吞吐量优先”的收集器。
在注重吞吐量和CPU资源优先的系统，可以优先考虑Parallel Scavenge+Parallel Old收集器的模式。

#### CMS收集器(并发标记-清除)
CMS（Concurrent Mark Seep）收集器是一种以获得最短停顿时间为目的的收集器。**非常适合重视响应速度，希望停顿时间最短，以给用户最好的体验的场景。**
CMS收集器是基于标记-清除算法的。它的过程主要包括以下四个步骤：
1. 初始标记。
2. 并发标记
3. 重新标记
4. 并发清除

其中，初始标记和重新标记这两个步骤还是需要“Stop The World”。初始标记GC Roots能直接关联上的对象，速度非常快，并发标记就是进行GC Roots 跟踪的过程，而重新标记阶段则是为了修正并发标记期间因为用户线程继续运作而导致标记变动的那一部分标记记录，这个阶段的停顿时间会比并发标记的时间短。
由于整个过程中耗时最长的并发标记和并发清除的过程收集器线程和用户线程可以并发工作，所以总体上来讲，其停顿时间是非常低的。

总结，CMS的过程是：停顿->初始标记->恢复->并发标记跟踪->停顿->重新标记（修正标记）->恢复->并发清除。
缺点：
1. 对CPU资源敏感
2. 无法处理浮动垃圾，可能出现Concurrent Mode Failure
3. 会产生大量空间碎片。（默认的情况下，CMS收集器顶不住要进行full gc时开启内存碎片整理，但是这样停顿时间就是变长。)

#### Garbage Fisrt(G1)收集器
G1收集器是当前收集器最前沿的研究成果之一。它是一款面向服务端的垃圾收集器，与其他收集器相比，它有如下有点：
1. 并行与并发：G1充分利用多CPU、多核的硬件优势，来缩短STW停顿时间。
2. 分代收集
3. 空间整合：与CMS的标记-清理算法不同，G1整体上看是基于标记-整理算法实现的收集器，从局部（两个region之间）上来看是基于复制算法实现的。但无论如何它都不会产生内存空间碎片。
4. 可预测的停顿时间：这是G1相对于CMS的另一大优势，G1能够建立可预测的停顿时间模型，能够使用者明确指定在一个长度为M毫秒的时间片内，，消耗在垃圾回收上的时间不超过N毫秒。

之前的收集器的收集范围一般是新生代或者老年代，而G1不再是这样。G1将整个Java堆分成若干个大小相等的独立区域region。之所以G1能建立可预测的时间模型，**是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。**
G1会跟踪没一个region的垃圾堆积大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region的，这也是Garbage First名称的由来。**这种使用region划分内存空间以及有优先级的区域回收方式，保证了G1收集器可以在有限的时间内可以收集尽可能高的收集效率。**
tip:虚拟机通过Remembered Set来维护region的之间的引用，在GC roots tracing的时候避免保证不对全堆扫描。

G1收集器大概分为以下几个步骤：
1. 初始标记
2. 并发标记
3. 最终标记
4. 刷选回收

这前面的过程和CMS收集器基本一致。但是最后刷选回收阶段，首先会对各个region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划

## GC调优
先明确两个概念
* minor gc ：指发生在新生代的GC，因为Java对象大多朝生夕死的特性，所以minor gc非常频繁，一般回收速度也比较快。
* major gc：指发生在老年代的gc，出现了Major GC一般也会伴随着一次Minor GC所以也叫FUll GC。Major GC的速度一般会比Minor GC慢10倍以上

调优的目标：一个是将转移到老年代的对象数量降到最少，另一个是减少Full GC的执行次数和时间

调优tips
1. 如何选择各分区大小应该依赖应用程序中对象生命周期的分布情况：**如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。**
2. 通过一次Minor GC，降低CMS remark的时间。CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。
3.通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。
4.CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。

#### Minor GC 频繁
通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。
还可以通过调低对象晋升年龄和晋升大小，来使大对象和存活对象提前进入老年代。但是这有个隐患就是可能会导致Major GC提前爆发。理论上我们应该优先让系统进行Minor GC，因为Minor GC的执行效率远高于Major GC
在编码的时候，程序员也应该避免“朝生夕死”的短命大对象。也要防止大对象长期持有引用。

#### Major GC 频繁
导致Major GC频繁的原因有可能有下面几种
1. 老年代的空间不足。
2. CMS收集器下，老年代内存碎片太多，无法分配大内存对象
3. 新生代survivor的空间太小，导致分配对象时总是需要老年代来担保。
4. 大对象太多，导致对象都进入老年代
5. 老年代和持久代的扩容

针对上面的情况我们可以一个个的处理。
1. 增加老年代的大小
2. 设置参数-XX:+UseCMSCompactAtFullCollection,用于在CMS收集器顶不住要FUll GC时开启内存碎片整理。
3. 修改新生代大小和survivor空间的比例，来增大survivor空间
4. 调高对象晋升年龄和晋升大小，缓解老年代的压力
5. 通过参数固定堆大小和持久代大小

#### STW的时间太长
这个要看收集器，如果是Serial收集器，咱们可以修改为并行的多线程ParNew收集器来并行收集。如果是CMS的STW时间过长，我们可以设置CMSScavengeBeforeRemark用来保证Remark前强制进行一次Minor GC，来减少CMS重新标记时需要扫描的内存大小。








