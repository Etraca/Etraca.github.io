---
layout:     post
title:      Java类加载过程
subtitle:   Java类加载过程
date:       2019-03-10
author:     WPF
header-img: img/post-bg-cook.jpg
catalog: true
tags:
- jvm
- 类加载
- java
---

## 简述
Java虚拟机总共有5个阶段，分别是加载、验证、准备、解析和初始化。本文来分析一下各个阶段的具体动作。

## 加载
加载是类加载的第一个步骤，虚拟机规范并没规定它具体时机，但是它需要完成下面三件事。
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

这个阶段有几点需要注意：
* jvm对二进制字节流的来源并没有强制要求在class文件中获取。在这一基础上支持了很多技术，如：在zip包读取类，在网络中获取、运行时计算生成（动态代理技术）、其他文件或者数据库中获取。
* 数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但是数组类的元素类型需要类加载器去创建。
* Class对象也是放在方法区的。

## 验证
验证阶段是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机的自身安全。
1. 文件格式验证。
2. 元数据验证。包括语义分析和语义校验。
3. 字节码校验。主要通过数据流和控制流分析程序语义是否合法的、符合逻辑的。
4. 符号引用验证。

## 准备
准备阶段是正是为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区进行分配。这里的初始值指的变量的零值。但是注意如果变量被final修饰，则为常量这时候需要直接给它初始化成指定的值。

## 解析
解析阶段是虚拟机将常量池中的符号引用替换成直接引用的过程。先来区分一下符号引用和直接引用:
* 符号引用：符号引用以一组符号来描述所引用的类，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。引用的目标不一定已经加载到内存中了。
* 直接引用：直接引用可以是直接指向目标的指针，相对偏移量或者是一个能直接定位到目标的句柄。如果有了直接引用那么目标必须存在。

解析包括：
1. 类或者接口解析
2. 字段解析
3. 类方法解析
4. 接口方法解析

## 初始化
类初始化是类加载过程的最后一步。初始化阶段开始执行类定义的Java程序代码。类初始化其实是执行类构造器<clinit>()方法的过程。

<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。收集的顺序是由语句在源文件中出现的顺序决定，所以静态语句块只能访问定义在静态语句块之前的静态变量，定义在之后的变量，可以前面静态语句块可以赋值，但是不能访问。

<clinit>()方法与类的构造函数（实例构造器<init>()方法）不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕，因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是Object。

由于父类的<clinit>()方法先执行，也就意味着父类定义的静态语句块要比子类静态赋值操作和子类静态代码块都要先执行。

如果类中没有静态变量的赋值操作和静态语句块，那么类或者接口就不会为类生成<clinit>()方法

接口中不能使用静态语句块，但是可以有静态变量赋值操作。但是接口与类不同，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，只有当父接口中定义的变量被使用时，父接口才会初始化，另外接口的实现类在初始化是也一样不会执行接口的<clinit>()方法。

虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步、如果多个线程同事去初始化一个类，那么只有一个线程回去执行这个类的<clinit>()方法。****


